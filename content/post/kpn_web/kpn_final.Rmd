---
title: "KPN twitter analysis"
author: "David Jankoski"
output: html_document
---

```{r setup, echo = FALSE, warning=FALSE, message=FALSE}
library("tidyverse")
library("jsonlite")
library("forcats")

# Read in datasets
kpn_all <- readRDS("kpn_all.rds")
top20_hshtg <- readRDS("kpn_top20_hshtgs.rds")
kpn_tmls_act_json <- jsonlite::read_json("kpn_tmls_act.json")

```

<!-- load libs -->
<script src="https://d3js.org/d3.v5.js"></script>
<script src="libs/waypoints/lib/noframework.waypoints.min.js"></script>


<br><br><br><br>  
<br><br><br><br>  


### Top 20 hashtags that appear next to #KPN

```{r top20bars-r, echo = FALSE}
ggplot(top20_hshtg, aes(fct_reorder(hashtags, n), n )) +
  geom_col() +
  coord_flip() +
  theme_minimal() +
  labs(
    title = "Top 20 hashtags that co-appear with #KPN"
  )
```


<br><br><br><br>  
<br><br><br><br>  

<!-- Top 20 hashtags D3 version
     load svg container -->
<svg id="cont-top20bars-d3" width="880" height="350"></svg>
```{js, class.source = "top20bars-d3", echo = FALSE}

var waypoint_top20d3 = new Waypoint({
  
  element: document.getElementById("cont-top20bars-d3"),
  offset: '50%', 
  
  handler: function() {
    
    var cont = d3.select("#cont-top20bars-d3"),
        margin = {top: 10, right: 10, bottom: 30, left: 102},
        width  = +cont.attr("width") - margin.left - margin.right,
        height = +cont.attr("height") - margin.top - margin.bottom ;

    var svg = cont.append("g")
                  .attr("transform", 
                    "translate(" + margin.left + "," + margin.top + ")");

    // set the ranges
    var yscale = d3.scaleBand()
                   .range([0, height])
                   .padding(0.12);
    var xscale = d3.scaleLinear()
                   .range([0, width]);  

    d3.json("kpn_top20_hshtgs.json")
      .then(function(data) {
  
        yscale.domain(data.map(d => d.hashtags));
        xscale.domain([0, d3.max(data, d => d.n)]);
  
        svg.selectAll(".bar")
             .data(data)
           .enter().append("rect")
             .attr("class", "bar")
             .attr("y", d => yscale(d.hashtags))
             .attr("height", yscale.bandwidth())
             .attr("x", 0)
             .attr("width", 0)
             .attr("opacity", 0.2)
             .transition()
             .delay((d, i) => i * 70)
             .duration(800)
             .attr("width", d => xscale(d.n));
  
        svg.append("g")
           .attr("class", "xaxis")
           .attr("transform", "translate(0," + height + ")")
           .call(d3.axisBottom(xscale));
  
        cont.append("g")
            .attr("class", "yaxis")
            .attr("transform", "translate(100, " + margin.top + ")")
            .call(d3.axisLeft(yscale));
    });
      
       this.destroy()
  }
});
```



<br><br><br><br>  
<br><br><br><br>  


### Map tweets places

Where do the twitter users come from and what do they say ?

```{r tweetmap, echo = FALSE}

library("leaflet")
tw_icon <- 
  leaflet::awesomeIcons(
    icon= 'fa-twitter', 
    markerColor = 'blue', 
    iconColor = '#fff', 
    library = "fa"
  )

leaflet::leaflet(data = kpn_all) %>%
  leaflet::addProviderTiles(
    "OpenStreetMap.BlackAndWhite"
  ) %>%
  leaflet::setView(lat = 52.3702, lng = 4.8952, zoom = 9) %>%
  leaflet::addAwesomeMarkers(
    lng = ~ lng, lat = ~ lat,
    icon = tw_icon, popup = ~ text,
    label = ~ screen_name) 
```


<br><br><br><br>  
<br><br><br><br>  


### Retweet network 

Force directed layout of network of retweets



<br><br><br><br>  
<br><br><br><br>  


<!-- Force Network Graph
     load svg container -->
<svg id="cont-force-d3" width="1000" height="600"></svg>

```{js, class.source = "force-d3", echo = FALSE}

var waypoint_force = new Waypoint({
  
  element: document.getElementById("cont-force-d3"),
  offset: '50%', 
  
  handler: function() {
    
  // var svg = d3.select("svg"),
    var svg = d3.select("#cont-force-d3"),
      width = +svg.attr("width"),
      height = +svg.attr("height"),
      radius = 6,
      imgrad = 20;
  

  d3.json("kpn_retweet_graph.json")
    .then(function(graph) {
    
      var force = 
        d3.forceSimulation()
          .nodes(graph.nodes)
          // Forces
          .force("charge", d3.forceManyBody().strength(-50) )
          
          .force("link", d3.forceLink(graph.edges).id(d => d.name).distance(20) )
          
          .force("center", d3.forceCenter(width / 2, height / 2) )
          
          .force("radial", d3.forceRadial(30, width / 2, height / 2).strength(0.1) )
          
          .on("tick", ticked);

      var edges = 
        svg.append("g")
             .attr("class", "egdes")
           .selectAll("line")
             .data(graph.edges)
             .enter()
           .append("line")
             .style("stroke", "#000")
             .style("stroke-width", d => d.value * 2);
      
      var defs = 
        svg.append("svg:defs")
           .selectAll(".pattern")
             .data(graph.nodes)
           .enter().append("pattern")
             .attr("id", d => d.name)
             .attr("width", imgrad)
             .attr("height", imgrad)
             .attr("class", "pattern")
           .append("image")
             .attr("xlink:href", d => d.node_img)
             .attr("width", imgrad)
             .attr("height", imgrad)
             .attr("x", 1)
             .attr("y", 1);

      var nodes = 
        svg.append("g")
             .attr("class", "nodes")
           
           //.selectAll("image")
           .selectAll("circle")

             .data(graph.nodes)
             .enter()
           
           .append("circle")
           // .append("image")
           //   .attr("xlink:href", d => d.node_img)
           //   .attr("x", -8)
           //   .attr("y", -8)
           //   .attr("width", 16)
           //   .attr("height", 16)

             .attr("r", 10)
             
             //.style("fill", (d, i) => d3.schemeSet1[ (i % 11) ])
             .style("fill", d => "url(#"+d.name+")")

             .on('dblclick', connectedNodes)
           .call(d3.drag()
                   .on("start", dragstarted)
                   .on("drag",  dragged)
                   .on("end",   dragended)
            );
    
      //Add a simple tooltip
      nodes.append("title").text(d => d.name);

      // nodes.append("svg:image")
      //        .attr("xlink:href",  d => d.node_img)
      //        .attr("x", -8)
      //        .attr("y", -8)
      //        .attr("width", 22)
      //        .attr("height", 22)
      
      // Force simulation tick fun
      function ticked() {

        edges
            .attr("x1", d => d.source.x)
            .attr("y1", d => d.source.y)
            .attr("x2", d => d.target.x)
            .attr("y2", d => d.target.y);

        nodes
            .attr("transform", function(d) {
                return "translate(" + d.x + "," + d.y + ")";
            });

        // nodes
        //     //.attr("cx", function(d) { return d.x; })
        //     //.attr("cy", function(d) { return d.y; })
        //     // keeps nodes within a bounding box
        //     .attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)); })
        //     .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)); });
      };
    

      // Force drag funs
      function dragstarted(d) {
        if (!d3.event.active) force.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      };
      function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
      };
      function dragended(d) {
        if (!d3.event.active) force.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      };

    //Toggle stores whether the highlighting is on
    var toggle = 0;
    //Create an array logging what is connected to what
    var linkedByIndex = {};
    
    for (i = 0; i < graph.nodes.length; i++) {
        linkedByIndex[i + "," + i] = 1;
    };
    
    graph.edges.forEach(function (d) {
        linkedByIndex[d.source.index + "," + d.target.index] = 1;
    });

    //This function looks up whether a pair are neighbours
    function neighboring(a, b) {
        return linkedByIndex[a.index + "," + b.index];
    };

    function connectedNodes() {
        
        if (toggle == 0) {
            //Reduce the opacity of all but the neighbouring nodes
            d = d3.select(this).node().__data__;
            nodes.style("opacity", function (o) {
                return neighboring(d, o) | neighboring(o, d) ? 1 : 0.1;
            });
            edges.style("opacity", function (o) {
                return d.index==o.source.index | d.index==o.target.index ? 1 : 0.1;
            });
            //Reduce the op
            toggle = 1;
        
        } else {
            //Put them back to opacity=1
            nodes.style("opacity", 1);
            edges.style("opacity", 1);
            toggle = 0;
        }
      };
});
     this.destroy()
  }
});
    
```
